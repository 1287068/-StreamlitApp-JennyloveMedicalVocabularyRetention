import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# -------------------------------------------------
# App Header
# -------------------------------------------------
st.title("Jennylove â€“ Medical Vocabulary Retention")
st.caption("High School Medical / Health Science CTE")

st.markdown(
    """
This interactive model shows how **medical vocabulary retention changes over time**
for high school students and how **review timing** affects memory.

ðŸ“ **Initial instruction begins at 11:00 a.m.**
"""
)

# -------------------------------------------------
# Sidebar Controls
# -------------------------------------------------
st.sidebar.header("Student Learning Factors")

understanding = st.sidebar.slider(
    "Understanding After Lesson",
    0.5, 0.9, 0.75, 0.05
)

forgetting_speed = st.sidebar.slider(
    "Forgetting Speed",
    0.02, 0.10, 0.07, 0.01
)

review_quality = st.sidebar.slider(
    "Review Quality",
    0.0, 0.20, 0.08, 0.02
)

review_choices = st.sidebar.multiselect(
    "Review Times",
    [
        "3:00 p.m. (Same Day)",
        "8:00 p.m. (Same Day)",
        "Next Class Period (24 hours)"
    ],
    default=["3:00 p.m. (Same Day)", "Next Class Period (24 hours)"]
)

# -------------------------------------------------
# Time Setup
# -------------------------------------------------
start_time = datetime.strptime("11:00", "%H:%M")
t = np.linspace(0, 72, 400)

review_times = {
    "3:00 p.m. (Same Day)": 4,
    "8:00 p.m. (Same Day)": 9,
    "Next Class Period (24 hours)": 24
}

selected_reviews = [review_times[r] for r in review_choices]

# -------------------------------------------------
# Retention Model
# -------------------------------------------------
def retention_curve(t, reviews):
    r = understanding * np.exp(-forgetting_speed * t)
    for review in reviews:
        r[t >= review] += review_quality * np.exp(
            -forgetting_speed * (t[t >= review] - review)
        )
    return np.clip(r, 0, 1)

retention = retention_curve(t, selected_reviews)

# -------------------------------------------------
# Clock Labels
# -------------------------------------------------
clock_hours = [0, 4, 9, 24, 48, 72]
clock_labels = []

for h in clock_hours:
    time_label = (start_time + timedelta(hours=h)).strftime("%I:%M %p")
    day = h // 24
    if day > 0:
        time_label += f" (Day {day + 1})"
    clock_labels.append(time_label)

# -------------------------------------------------
# Plot
# -------------------------------------------------
fig, ax = plt.subplots()
ax.plot(t, retention, linewidth=2)

for r in selected_reviews:
    ax.axvline(r, linestyle="--", alpha=0.6)

ax.set_ylim(0, 1.05)
ax.set_ylabel("Vocabulary Remembered")
ax.set_xlabel("Time Since Instruction")
ax.set_title("Medical Vocabulary Retention (0â€“72 Hours)")

ax.set_xticks(clock_hours)
ax.set_xticklabels(clock_labels, rotation=30)

st.pyplot(fig)

# -------------------------------------------------
# Key Values Table
# -------------------------------------------------
st.subheader("Retention at Key Time Points")

checkpoints = np.array([0, 24, 48, 72])
values = retention_curve(checkpoints, selected_reviews)

st.table({
    "Time After Instruction": [
        "11:00 a.m. (Start)",
        "24 Hours",
        "48 Hours",
        "72 Hours"
    ],
    "Vocabulary Remembered (%)": (values * 100).round(1)
})

# -------------------------------------------------
# Interpretation
# -------------------------------------------------
st.markdown(
    """
### Instructional Takeaways

- **Same-day review** significantly improves next-day retention  
- Waiting until the next class period results in **avoidable loss**
- Forgetting is **normal**, not a sign of low ability
- Short retrieval activities outperform rereading

This model supports:
- Bell ringers  
- Exit tickets  
- Spiral review  
- Evidence-based CTE instruction  
"""
)
